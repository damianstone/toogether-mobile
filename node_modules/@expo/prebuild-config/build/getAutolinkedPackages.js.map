{"version":3,"file":"getAutolinkedPackages.js","names":["getAutolinkedPackagesAsync","projectRoot","platforms","autolinking","importExpoModulesAutolinking","searchPaths","resolveSearchPathsAsync","platformPaths","Promise","all","map","platform","findModulesAsync","silent","resolvePackagesList","allPlatformPaths","paths","Object","keys","flat","uniquePaths","Set","sort","shouldSkipAutoPlugin","config","plugin","Array","isArray","_internal","autolinkedModules","pluginId","isIncluded","includes"],"sources":["../src/getAutolinkedPackages.ts"],"sourcesContent":["import { ModPlatform, StaticPlugin } from '@expo/config-plugins';\nimport { ExpoConfig } from '@expo/config-types';\n\nimport { importExpoModulesAutolinking } from './importExpoModulesAutolinking';\n\n/**\n * Returns a list of packages that are autolinked to a project.\n *\n * @param projectRoot\n * @param platforms platforms to check for\n * @returns list of packages ex: `['expo-camera', 'react-native-screens']`\n */\nexport async function getAutolinkedPackagesAsync(\n  projectRoot: string,\n  platforms: ModPlatform[] = ['ios', 'android']\n) {\n  const autolinking = importExpoModulesAutolinking(projectRoot);\n  const searchPaths = await autolinking.resolveSearchPathsAsync(null, projectRoot);\n\n  const platformPaths = await Promise.all(\n    platforms.map((platform) =>\n      autolinking.findModulesAsync({\n        platform,\n        searchPaths,\n        silent: true,\n      })\n    )\n  );\n\n  return resolvePackagesList(platformPaths);\n}\n\nexport function resolvePackagesList(platformPaths: Record<string, any>[]) {\n  const allPlatformPaths = platformPaths.map((paths) => Object.keys(paths)).flat();\n\n  const uniquePaths = [...new Set(allPlatformPaths)];\n\n  return uniquePaths.sort();\n}\n\nexport function shouldSkipAutoPlugin(\n  config: Pick<ExpoConfig, '_internal'>,\n  plugin: StaticPlugin | string\n) {\n  // Hack workaround because expo-dev-client doesn't use expo modules.\n  if (plugin === 'expo-dev-client') {\n    return false;\n  }\n\n  // Only perform the check if `autolinkedModules` is defined, otherwise we assume\n  // this is a legacy runner which doesn't support autolinking.\n  if (Array.isArray(config._internal?.autolinkedModules)) {\n    // Resolve the pluginId as a string.\n    const pluginId = Array.isArray(plugin) ? plugin[0] : plugin;\n    if (typeof pluginId === 'string') {\n      // Determine if the autolinked modules list includes our moduleId\n      const isIncluded = config._internal!.autolinkedModules.includes(pluginId);\n      if (!isIncluded) {\n        // If it doesn't then we know that any potential plugin shouldn't be applied automatically.\n        return true;\n      }\n    }\n  }\n  return false;\n}\n"],"mappings":";;;;;;;;;AAGA;EAAA;;EAAA;IAAA;EAAA;;EAAA;AAAA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,eAAeA,0BAAf,CACLC,WADK,EAELC,SAAwB,GAAG,CAAC,KAAD,EAAQ,SAAR,CAFtB,EAGL;EACA,MAAMC,WAAW,GAAG,IAAAC,4DAAA,EAA6BH,WAA7B,CAApB;EACA,MAAMI,WAAW,GAAG,MAAMF,WAAW,CAACG,uBAAZ,CAAoC,IAApC,EAA0CL,WAA1C,CAA1B;EAEA,MAAMM,aAAa,GAAG,MAAMC,OAAO,CAACC,GAAR,CAC1BP,SAAS,CAACQ,GAAV,CAAeC,QAAD,IACZR,WAAW,CAACS,gBAAZ,CAA6B;IAC3BD,QAD2B;IAE3BN,WAF2B;IAG3BQ,MAAM,EAAE;EAHmB,CAA7B,CADF,CAD0B,CAA5B;EAUA,OAAOC,mBAAmB,CAACP,aAAD,CAA1B;AACD;;AAEM,SAASO,mBAAT,CAA6BP,aAA7B,EAAmE;EACxE,MAAMQ,gBAAgB,GAAGR,aAAa,CAACG,GAAd,CAAmBM,KAAD,IAAWC,MAAM,CAACC,IAAP,CAAYF,KAAZ,CAA7B,EAAiDG,IAAjD,EAAzB;EAEA,MAAMC,WAAW,GAAG,CAAC,GAAG,IAAIC,GAAJ,CAAQN,gBAAR,CAAJ,CAApB;EAEA,OAAOK,WAAW,CAACE,IAAZ,EAAP;AACD;;AAEM,SAASC,oBAAT,CACLC,MADK,EAELC,MAFK,EAGL;EAAA;;EACA;EACA,IAAIA,MAAM,KAAK,iBAAf,EAAkC;IAChC,OAAO,KAAP;EACD,CAJD,CAMA;EACA;;;EACA,IAAIC,KAAK,CAACC,OAAN,sBAAcH,MAAM,CAACI,SAArB,sDAAc,kBAAkBC,iBAAhC,CAAJ,EAAwD;IACtD;IACA,MAAMC,QAAQ,GAAGJ,KAAK,CAACC,OAAN,CAAcF,MAAd,IAAwBA,MAAM,CAAC,CAAD,CAA9B,GAAoCA,MAArD;;IACA,IAAI,OAAOK,QAAP,KAAoB,QAAxB,EAAkC;MAChC;MACA,MAAMC,UAAU,GAAGP,MAAM,CAACI,SAAP,CAAkBC,iBAAlB,CAAoCG,QAApC,CAA6CF,QAA7C,CAAnB;;MACA,IAAI,CAACC,UAAL,EAAiB;QACf;QACA,OAAO,IAAP;MACD;IACF;EACF;;EACD,OAAO,KAAP;AACD"}